(defvar state);declare global variable state 

(defun start ()
(data) (checkB))
(defun data()
(
format t "~%WATER JUG PROBLEM")
(format t "~%FILL JUGNAME: (fillJUGNAME)")
(format t "~%EMPTY JUGNAME: (emptyJUGNAME)")
(format t "~%PUT A TO B : (putAtoB)")
(format t "~%~%GIVE THE STARTING STATE OF EACH JUG IN FORM (A B C) E.G (0 0 0)")
(format t "~%MAX A=7,MAX B=4 AND MAX C=2: ")
(setf state (read));SET VALUE AT VARIABLE STATE
)

(format t "~%STARTING CONDITION OF EACH JUG: ~3a" state)
;FILLING A
(defun fillA () (let((x(first state))(y(second state))(z(third state)))
(if (< x 7) (let ((newstate (list 7 y z)))
(prog1 state (format t "~%NEW STATE: ~3a" newstate ))
(setf (first state) 7)))
(if (>= x 7) (format t "~%A IS ALREADY FULL")))
(checkB))

;FILLING B
(defun fillB () (let((x(first state))(y(second state))(z(third state)))
(if (< y 4) (let ((newstate (list x 4 z)))
(prog1 state (format t "~%NEW STATE: ~3a" newstate ))
(setf (second state) 4)))
(if (>= y 4)(format t "~%B IS ALREADY FULL")))
(checkB))

;FILLING C
(defun fillC () (let((x(first state))(y(second state))(z(third state)))
(if (< z 2) (let ((newstate (list x y 2)))
(prog1 state (format t "~%NEW STATE: ~3a" newstate ))
(setf (third state) 2)))
(if (>= z 2) (format t "~%C IS ALREADY FULL")))
(checkB) )

;EMPTY A
(defun emptyA () (let((x(first state))(y(second state))(z(third state)))
(if (> x 0) (let ((newstate (list 0 y z)))
(prog1 state (format t "~%NEW STATE: ~3a" newstate ))
(setf (first state) 0)))
(if (<= x 0) (format t "~%A IS ALREADY EMPTY")))
(checkB))

;EMPTY Î’
(defun emptyB () (let((x(first state))(y(second state))(z(third state)))
(if (> y 0) (let ((newstate (list x 0 z)))
(prog1 state (format t "~%NEW STATE: ~3a" newstate ))
(setf (second state) 0)))
(if (<= y 0) (format t "~%B IS ALREADY EMPTY")))
(checkB))

;EMPTY C
(defun emptyC () (let((x(first state))(y(second state))(z(third state)))
(if (> z 0) (let ((newstate (list x y 0)))
(prog1 state (format t "~%NEW STATE: ~3a" newstate ))
(setf (third state) 0)))
(if (<= z 0) (format t "~%C IS ALREADY EMPTY")))
(checkB))

;PUT A TO B
(defun putAtoB () (let((x(first state))(y(second state))(z(third state)))
(cond((<= x 0) (format t"~%A IS ALREADY EMPTY"))
((>= y 4) (format t"~%B IS FULL"))
((and (> x 0) (< y 4))
(let ((local (- 4 y)))
(if (or (> x local)(= x local))
(let ((newstate (list (- x (- 4 y)) 4 z)))
(setf (first state) (first newstate))
(setf (second state) (second newstate))
(setf (third state) (third newstate))
(format t "~%NEW STATE: ~3a" newstate))
(let ((newstate (list 0 (+ y x) z)))
(setf (first state) (first newstate))
(setf (second state) (second newstate))
(setf (third state) (third newstate))
(format t "~%NEW STATE: ~3a" newstate))
)))))
(checkB))

;PUT B TO A
(defun putBtoA () (let((x(first state))(y(second state))(z(third state)))
(cond((>= x 7) (format t"~%A IS FULL"))
((<= y 0) (format t"~%B IS EMPTY"))
((and (> y 0) (< x 7))
(let ((local (- 7 x)))
(if (or (> x local)(= x local))
(let ((newstate (list 7 (- y (- 7 x)) z)))
(setf (first state) (first newstate))
(setf (second state) (second newstate))
(setf (third state) (third newstate))
(format t "~%NEW STATE: ~3a" newstate))
(let ((newstate (list (+ y x) 0 z)))
(setf (first state) (first newstate))
(setf (second state) (second newstate))
(setf (third state) (third newstate))
(format t "~%NEW STATE: ~3a" newstate))
)))))
(checkB))

;PUT A TO C
(defun putAtoC () (let((x(first state))(y(second state))(z(third state)))
(cond((<= x 0) (format t"~%A IS EMPTY"))
((>= z 2) (format t"~%C IS FULL"))
((and (> x 0) (< z 2))
(let ((local (- 2 z)))
(if (or (> x local)(= x local))
(let ((newstate (list (- x (- 2 z)) y 2)))
(setf (first state) (first newstate))
(setf (second state) (second newstate))
(setf (third state) (third newstate))
(format t "~%NEW STATE: ~3a" newstate))
(let ((newstate (list 0 y (+ z x))))
(setf (first state) (first newstate))
(setf (second state) (second newstate))
(setf (third state) (third newstate))
(format t "~%NEW STATE: ~3a" newstate))
)))))
(checkB))

;PUT C TO A
(defun putCtoA () (let((x(first state))(y(second state))(z(third state)))
(cond((>= x 7) (format t"~%A IS FULL"))
((<= z 0) (format t"~%C IS EMPTY"))
((and (> z 0) (< x 7))
(let ((local (- 7 x)))
(if (or (> x local)(= x local))
(let ((newstate (list 7 y (- z (- 7 x)))))
(setf (first state) (first newstate))
(setf (second state) (second newstate))
(setf (third state) (third newstate))
(format t "~%NEW STATE: ~3a" newstate))
(let ((newstate (list (+ z x) y 0)))
(setf (first state) (first newstate))
(setf (second state) (second newstate))
(setf (third state) (third newstate))
(format t "~%NEW STATE: ~3a" newstate))
)))))
(checkB))

;PUT B TO C
(defun putBtoC () (let((x(first state))(y(second state))(z(third state)))
(cond((<= y 0) (format t"~%B IS EMPTY"))
((>= z 2) (format t"~%C IS FULL"))
((and (> y 0) (< z 2))
(let ((local (- 2 z)))
(if (or (> y local)(= y local))
(let ((newstate (list x (- y (- 2 z)) 2)))
(setf (first state) (first newstate))
(setf (second state) (second newstate))
(setf (third state) (third newstate))
(format t "~%NEW STATE: ~3a" newstate))
(let ((newstate (list x 0 (+ z y))))
(setf (first state) (first newstate))
(setf (second state) (second newstate))
(setf (third state) (third newstate))
(format t "~%NEW STATE: ~3a" newstate))
)))))
(checkB))

;PUT C TO B
(defun putCtoB () (let((x(first state))(y(second state))(z(third state)))
(cond((>= y 4) (format t"~%B IS FULL"))
((<= z 0) (format t"~%C IS EMPTY"))
((and (> z 0) (< y 4))
(let ((local (- 4 y)))
(if (or (> y local)(= y local))
(let ((newstate (list x 4 (- z (- 4 y)))))
(setf (first state) (first newstate))
(setf (second state) (second newstate))
(setf (third state) (third newstate))
(format t "~%NEW STATE: ~3a" newstate))
(let ((newstate (list x (+ y z) 0)))
(setf (first state) (first newstate))
(setf (second state) (second newstate))
(setf (third state) (third newstate))
(format t "~%NEW STATE: ~3a" newstate))
)))))
(checkB))

;CHECK IF B=1
(defun checkB () (let ((y(second state)))
(if (= y 1) (format t "~% YOU WIN B=1."
))))
